from abc import ABC, abstractmethod
import numpy as np
from copy import deepcopy as dcp

from genetic_algorithm.utils.helpers import ensure_np_array
from genetic_algorithm.classes.base_classes import OperatorBase
from genetic_algorithm.classes.chromosome import Chromosome


class Operator(OperatorBase):
    """
    Main class that has genetic operators as methods.
    Inherits from the OperatorBase class to make sure the class
    satisfies and follows certain requirements.
    """
    def __init__(self):
        self._n_crossover = 0
        self._n_mutation = 0
        self._n_repair = 0
        self.verbose = 2

    @property
    def n_crossover(self):
        return _n_crossover

    @n_crossover.setter
    def n_crossover(self, value):
        self._n_crossover = value

    @property
    def n_mutation(self):
        return _n_mutation

    @n_mutation.setter
    def n_mutation(self, value):
        self._n_mutation = value

    @property
    def n_repair(self):
        return _n_repair

    @n_repair.setter
    def n_repair(self, value):
        self._n_repair = value

    def crossover(self, chromosomes, crossover_type, args={}):
        """
        Takes a numpy array of two chromosome instances and performs a crossover operation between them.
        Args:
            chromosomes -> Numpy array of Chromosome class instances of size 2
            crossover_type -> String. Must be one of ['uniform', 'single_point', 'multiple_points', 'user_defined']
        Returns:
            children -> Numpy array of 2 offsprings generated by the crossover operation 
        """
        if crossover_type == "single-point":
            cutoff = args.get("cutoff_proportion")
            if cutoff is None:
                if self.verbose == 2:
                    print(f"Cutoff proportion is not given. Single-point crossover will generate one randomly.")           
            children = self._single_point_crossover(chromosomes, cutoff)

        elif crossover_type == "uniform":
            uniform_mask = args.get("uniform_mask")
            if uniform_mask is None:
                if self.verbose == 2:
                    print(f"Uniform mask is not given. Uniform crossover will generate one randomly.")           
            children = self._uniform_crossover(chromosomes, uniform_mask)

        
        return children

    def _single_point_crossover(self, chromosomes, cutoff=None):
        chromosome1, chromosome2 = chromosomes[0], chromosomes[1]
        length = len(chromosome1.genotype)

        if cutoff is None:
            cutoff = np.random.uniform()

        if cutoff < 0 or cutoff > 1:
            raise(ValueError("Cutoff value must be between 0 and 1. Eg for 50%, use cutoff=0.5."))

        cutoff_idx = int(length * cutoff)

        gen1 = chromosome1.genotype
        gen2 = chromosome2.genotype

        hold1 = dcp(gen1[cutoff_idx:])
        hold2 = dcp(gen2[cutoff_idx:])
        gen1[cutoff_idx:] = hold2
        gen2[cutoff_idx:] = hold1

        child1 = Chromosome(gen1)
        child2 = Chromosome(gen2)

        children = ensure_np_array([child1, child2])

        return children

    def _uniform_crossover(self, chromosomes, uniform_mask=None):
        chromosome1, chromosome2 = chromosomes[0], chromosomes[1]
        length = len(chromosome1.genotype)

        if uniform_mask is None:
            uniform_mask = np.random.randint(2, size=length)

        gen1 = dcp(chromosome1.genotype)
        gen2 = dcp(chromosome2.genotype)

        for idx in range(length):
            if uniform_mask[idx] == 0:
                gen1[idx] = chromosome1.genotype[idx]
                gen2[idx] = chromosome2.genotype[idx]
            else:
                gen1[idx] = chromosome2.genotype[idx]
                gen2[idx] = chromosome1.genotype[idx]

        child1 = Chromosome(gen1)
        child2 = Chromosome(gen2)

        children = ensure_np_array([child1, child2])

        return children

    def mutate(self):
        pass

    def evaluate(self):
        pass